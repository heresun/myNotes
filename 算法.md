# 基础算法

常见的时间复杂度

| 执行次数函数举例         | 阶               | 非正式术语 |
| ------------------------ | ---------------- | ---------- |
| 12                       | O(1)             | 常数阶     |
| 2n+3                     | O(n)             | 线性阶     |
| 3n<sup>2</sup>+2n+1      | O(n<sup>2</sup>) | 平方阶     |
| 5log<sub>2</sub>n+20     | O(logn)          | 对数阶     |
| 2n+3nlog<sub>2</sub>n+19 | O(nlogn)         | nlogn阶    |
| 6n3+2n2+3n+4             | O(n<sup>3</sup>) | 立方阶     |
| 2<sup>n</sup>            | O(2<sup>n</sup>) | 指数阶     |

注意，经常将log<sub>2</sub>n（以2为底的对数）简写成log

![img](https://img2018.cnblogs.com/blog/643405/201903/643405-20190316231939821-1936400043.jpg)

## 排序算法

![img](https://img-blog.csdn.net/20180807094112221?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTYyNjAw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

> 排序算法的稳定性是指相等的两个数在排序前后的前后位置不发生变化

### 1.交换排序

#### 冒泡排序（以升序为例）

假设有一个整型数组 `source`, 长度为`length`

每轮比较结束后都会在数组尾部产生一个最大数，那么在下轮中就不需要和这个最大数比较，即每轮比较后减少一个数，以此类推，因此比较的轮数应为`length-1`

每轮的比较都需要从数组的`0`开始，因此代码如下

```java
public static void bubbleSort(int[] source){
    int temp;
    for(int i=0; i < source.length-1; i++){
        for(int j=0; j < source.length-1-i;j++){
            if(source[j]>source[j+1]){//如果将>改为<则为倒序
                temp = source[j+1];
                source[j+1] = source[j];
                source[j] = temp;
            }
        }
    }
}
```

#### 快速排序

快速排序首先选取**一个基准数**，然后指定**两个指针**，分别指向数列的开头和结尾，

从数列最右侧开始与该基准数比较，如果大于等于基准数，则将右侧的指针左移，否则将右侧指针指向的数字赋值给左侧指针指向位置；然后比较左侧的数，如果小于等于基准数，则将左侧的指针右移，否则将左指针指向的数字赋值给右侧指针指向的位置。

以上步骤为一个循环，循环的技术条件为右侧指针大于左侧指针。

```java
public static void quickSort(int[] arr, int start, int end){
    //递归结束条件
    if(start>=end){
        return;
    }
    //选取一个基准数
    int base = arr[start];
    //记录需要排序的序列的起始终结位置
    int low = start;
    int high = end;
    
    while(low<high){
        //当右侧数据大于等于base时，右侧指针左移
        while(low<high && base<=arr[hith]){
            high--;
        }
        //当右侧数据小于base时，将high位置的数字赋给low位置
        arr[low] = arr[high];
        //当左侧数据小于等于base时，左侧指针右移
        while(low<high && base>=arr[low]){
            low++;
        }
        //当左侧数据大于base时，将low位置的数字赋给high位置
        arr[high] = arr[low];
    }
    
    //此时，low==high，将base赋值给low位置
    arr[low] = base;
    //递归排列比base小的序列
    quickSort(arr, start, low-1);
    //递归排列比base大的序列
    quickSort(arr, low+1, end);
}
```



