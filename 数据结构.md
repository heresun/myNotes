# 递归

在方法中调用本方法

特点：

+ 自己调用自己
+ 有终止条件

## 斐波那契数列

```java
//获取斐波那契数列第i个值
public static int fibonacciItem(int i){
    if(i<1){
        throw new IllegalArgumentsException("参数为非零正整数");
    }
    if(i==1 || i==2){
        return 1;
    }else{
        return fibonacciItem(i-1)+fibonacciItem(i-2);
    }
}

//打印前n个斐波那契数列
// 迭代法
public static void fibonacciSeq(int n){
	int pre = 1;
    int now = 1;
    int mid;
    for(int i=1; i<=n; i++){
        if(i<=2){
			sout(1+" ")
        }else{
        	mid = pre + now;
            sout(mid+" ");
            pre = now;
            now = mid;
        }
    }
}
//使用第一个递归函数
public static void fibonacciSeq(int n){
    for(int i=1; i<=n; i++){
        sout(fibonacciIte(i)+" ");
    }
}
```

## 汉诺塔

```java
public static void hanoi(int n, char from, char mid, char dest){
        if (n==1){
            System.out.println("把第 "+n+" 个盘子从 "+from+" 移到 "+dest);
        }else{
            hanoi(n-1,from,dest,mid);
            System.out.println("把第 "+n+" 个盘子从 "+from+" 移到 "+dest);
            hanoi(n-1,mid, from, dest);
        }
    }
```



# 树

本笔记的树根节点算为第一层，其深度为1，其高度为数的高度

**深度定义是从上往下的，高度定义是从下往上的**，二者相等，只是概念不同

## 树的基本概念

![image-20200219222511724](C:\Users\14402\AppData\Roaming\Typora\typora-user-images\image-20200219222511724.png)

**树的度=Max(节点度)**

## 二叉树

**即每个节点最多有两个子节点**

### 满二叉树

即二叉树的每一层都是该层的最大节点数，**也可以说所有叶子节点都在最后一层**

节点的总数为**2<sup>n</sup>-1**, n为树的 深度 或 高度 或 层数

### 完全二叉树

+ 其叶子节点在最后一层和倒数第二层上
+ 且左侧的叶子节点连续
+ 右侧的叶子节点连续

#### 性质

> 假设一棵有n个节点的树，n<sub>0</sub>是度为0的节点总数（即叶子节点数），n<sub>1</sub>是度为1的节点数，n<sub>2</sub>是度为2的节点数

1. n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>

2. n=1+n<sub>1</sub>+2n<sub>2</sub>

3. n<sub>1</sub>为0或1

4. 由1，2两式消去n<sub>2</sub>可得：n=2n<sub>0</sub>+n<sub>1</sub>-1 ,由性质3可知，n<sub>0</sub>=n/2或者n<sub>0</sub>=(n+1)/2

   > 简单来算就是 n<sub>0</sub>=n/2,因为当n为奇数时说明n<sub>1</sub>=0, 向上取整可得n<sub>0</sub>
   >
   > 当n为偶数时说明n<sub>1</sub>=1, 结果刚好就是n<sub>0</sub>

5. 完全二叉树的高度为**log<sub>2</sub>n+1**

### 二叉树的存储

#### 链式存储

即创建一个树节点，每个节点有两个指针，分别指向两个子节点，叶子节点的两个指针为`null`

完全二叉树节点的添加：

```java
    preLev:指向上一层正在添加子节点的节点
    curLev：指向当前层第一个节点
    cursor：游标指针，每次添加节点时，它指向上一次添加的节点，并将上一次添加节点的右兄弟节点指向当前添加			 的节点，然后指向当前添加的节点
//添加一个节点
    public void add(TreeNode node){
        if (preLev.getLeft()==null){
            preLev.setLeft(node);
            size++;
            //如果当前节点是该层的第一个节点，则将当前层指针和游标指向新添加的节点
            if (size==Math.pow(2,getHigh()-1)){
                curLev=cursor=node;
            }else {//否则，将当前节点设为前一个节点的右兄弟节点，并将游标右移
                cursor.setBroRight(node);
                cursor = node;
            }

        }else if (preLev.getRight()==null){
            preLev.setRight(node);
            size++;
            cursor.setBroRight(node);
            cursor=node;
            //如果当前节点是否是当前层最后一个节点，则把前一层的指针执行当前层的指针指向的位置
            if (size-(Math.pow(2,getHigh()-1)-1)==Math.pow(2,getHigh()-1)){
                preLev=curLev;
            }else if (preLev.getBroRight()!=null){
                //如果前一层指针指向的节点有右兄弟节点，则将前一层指针指向其右兄弟节点
                preLev = preLev.getBroRight();
            }
        }
    }
```

完全二叉树的遍历：

+ 前序遍历：先遍历父节点，再左节点，右节点
+ 中序遍历：先遍历左节点，再父节点，右节点
+ 后序遍历：先遍历左节点，再右节点，再父节点

> 所谓前中后指的是父节点遍历的时机。

完全二叉树的查找：

+ 前序查找

+ 中序查找

+ 后序查找

  以前序查找为例:

  ```java
  public TreeNode preSearch(int i) {
              TreeNode treeNode = null;
              if (this.getData() == i) {
                  return this;
              } else {
                  if (this.getLeft() != null) {
                      treeNode = this.getLeft().preSearch(i);
                  }
                  if (treeNode != null) {
                      return treeNode;
                  }
                  if (this.getRight() != null) {
                      treeNode = this.getRight().preSearch(i);
                  }
              }
              return treeNode;
          }
  ```

  

#### 顺序存储

顺序存储一般只考虑完全二叉树

假设有一棵完全二叉树：

![image-20200220201045847](C:\Users\14402\AppData\Roaming\Typora\typora-user-images\image-20200220201045847.png)

其顺序存储结构如下：

![image-20200220201308109](C:\Users\14402\AppData\Roaming\Typora\typora-user-images\image-20200220201308109.png)

性质：

1. 索引为n的节点的左子节点的下标：2*n+1
2. 索引为n的节点的右子节点的下标：2*n+2
3. 索引为n的节点的双亲节点的下标：(n-1)/2



### 线索二叉树

将二叉树按照**先序**、**中序**或**后序**线索化后的的二叉树称为线索二叉树。

![ ](C:\Users\14402\AppData\Roaming\Typora\typora-user-images\image-20200220201045847.png)





# 堆

堆通常可以被看做是一棵树的数组对象。

## 性质

+ 堆中的某个节点的值总是**不大于**或**不小于**其父节点的值（大顶堆和小顶堆）
+ 堆总是一棵完全二叉树

