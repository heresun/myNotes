# JVM参数

+ `-XX:+<option>`：开启`option`选项
+ `-XX:-<option>`：关闭`option`选项
+ `-XX:<option>=<value>`：将`option`的值设置为`value`



# JVM助记符

+ `ldc`：表示将int,float,或者string类型的常量从常量池中推送至栈顶
+ `bipush`：表示将单字节(-128~127)的常量推送至栈顶
+ `sipush`：表示将短整型(--32768~32767)的产量推送至栈顶
+ `iconst_0`~`iconst_5`：表示将int型0~5常量推送至栈顶
+ `iconst_m1`: 表示将int型的-1常量推送至栈顶
+ `anewarray`：创建一个引用类型的一维数组，并将其引用值压入栈顶
+ `newarray`：创建一个指定的原始类型的数组，并将其引用压入栈顶
+ `multianewarray`：创建一个（原始类型或引用类型）多维数组，并将其引用值压入栈顶

# JVM的内存模型与内存结构

## 内存结构

Java的内存结构包括堆、栈、方法区等，Java程序启动后会初始化这些内存中的数据。

![image-20200215143420505](C:\Users\14402\AppData\Roaming\Typora\typora-user-images\image-20200215143420505.png)

+ 程序计数器

  > + **说明:**
  >
  >   线程私有的一小块内存空间。
  >
  >   **之所以为私有**：JVM的多线程时通过线程轮流切换并分配处理器时间片的方式实现的，任何确定时刻，一个处理器都只会执行一条线程的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，每条线程之间互不影响。
  >
  >   可以看作当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里，字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的指令，各种基础功能都需要依赖程序计数器
  >
  >   如果正在执行的时一个Java方法，这个程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是一个Native方法，该程序计数器值为空
  >
  > + **异常定义：**
  >
  >   此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

+ 虚拟机栈

  > + **说明：**
  >
  >   该内存区域的生命周期与线程一致，描述了Java方法执行的内存模型：
  >
  >   > 每个方法执行都会创建一个**栈帧**，用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法出入口**等信息。每一个方法从开始到结束的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
  >   >
  >   > 该内存区域最重要的一块为：**局部变量表**
  >   >
  >   > > 这里存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令地址）
  >   > >
  >   > > 处理64位长的long和double类型占用两个**局部变量空间(Slot)**外，其他均为一个
  >   > >
  >   > > 局部变量表的内存空间在编译期完成分配，所以进入一个方法时，这个方法需要在栈帧分配多大的局部变量表时确定的，运行期不会改变
  >
  > + 异常定义
  >
  >   + `StackOverflowError`：线程请求的栈深大于虚拟机允许的深度
  >   + `OutOfMemoryError`: 如果虚拟机栈可以扩展，但是在扩展时无法申请到足够的内存
  
+ 本地方法栈

  > 功能类似于虚拟机栈，不同之处在于，本地方法栈是为虚拟机使用到的本地方法提供服务
  >
  > 虚拟机规范对本地方法栈中的方法使用的语言、使用方式与数据结构没有强制规定

+ 堆

  > + **说明**
  >
  >   该区域的唯一作用就是存放对象实例，在虚拟机启动时创建
  >
  >   > 虚拟机规范表示：所有对象实例和数组都要在该区域上分配，但是随着JIT编译器的发展和逃逸分析技术的成熟，**栈上分配**和**标量替换**优化技术将会导致一些微妙的变化，所有对象都在堆上分配也渐渐不那么绝对了。
  >   >
  >   > 从内存回收角度看：堆是GC管理的主要区域，由于现在的GC都是分代管理，因此，堆还可以细分为新生代和老年代；
  >   >
  >   > 从内存分配角度看：线程共享的堆可能划分出线程私有的分配缓冲区（TLAB），但是无论内存怎么划分，其中存储的都是对象，划分的目的是为了便于管理
  >   >
  >   > 堆可以是不连续的物理内存，但是逻辑上是连续的，其大小一般都是可扩展的，通过**-Xms**,**-Xmx**分配
  >
  > + **异常定义**
  >
  >   + `OutOfMemoryError`：当堆的内存无法完成实例分配且无法再扩展时

+ 方法区

  > 方法区是虚拟机规范的称呼，每个虚拟机都有不同的实现，HotSpot在1.7之前实现方式为永久代，1.8以后为元空间
  >
  > + **说明**
  >
  >   用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，在虚拟机启动时创建。
  >
  >   JVM根据方法区中的字节码为类生成Class/Method/Field等对象，这些对象用于反射中。
  >
  >   > 1.8以后HotSpot取消了永久代，改为元空间，元空间没有使用堆内存，而是与堆不相连的本地内存，这也就是说理论上元空间的大小和系统使用的内存大小是一致的，元空间没有永久代的`-XX:MaxPermSize`的上限，因此不太容易发生OOM 。
  >   >
  >   > 由于永久代很难设置一个合适的大小，其调优比较困难，影响因素较多，如类的数量、常量数量等，永久代的元数据也会随着一次full GC 发生移动，比较消耗虚拟机性能。除此外，HotSpot每种垃圾回收器需要特殊处理永久代中的元数据，因此将元数据从永久代剥离不仅实现了对元空间的无缝管理，也简化了Full GC 以及对以后的并发隔离类元数据等方面进行优化。

+ 运行时常量池

  > 1.8以后的运行时常量池位于元空间（依旧在方法区）
  >
  > 说到运行时常量池就必须提到class文件的**类常量池**：
  >
  > > class文件中除了保存类的版本、字段、方法、接口等描述性信息外，还有一项信息是常量池，它用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
  >
  > 运行时常量池除了存放符号引用，还会把翻译出来的直接引用放入运行时常量池中
  >
  > 相对于class文件类常量池，运行时常量池的一大特征就是具备动态性，也就是可以在运行时主动向常量池中（字符串常量池）存放常量，调用string的intern方法即可

+ 字符串常量池

  > 字符串常量池1.7  被从方法区移入堆，但是它属于运行时常量池，它用来存放字符串常量的引用以及字符串常量

## 内存模型

JVM的内存模型是和并发息息相关的，目的是保证多线程之间操作共享变量的正确性。关键字：`final`,`volatile`,`synchronized`


# 类加载器

在Java代码中，类型加载、链接与初始化过程都是在程序运行期完成的，这样提供了更大的灵活性和可能性，这点与其他编译型语言在编译期完成有所不同。

+ 类加载：查找并加载类的二进制数据
+ 链接
  + 验证：确保被加载类的正确性
  + 准备：为类的静态变量分配内存，并将其初始化为**默认值**
  + 解析：把类中的符号引用转换为直接引用
+ 初始化：为类的静态变量赋予正确的**初始值**
+ 使用
+ 卸载（可选）

```java
// 这段代码说明了在初始化阶段，静态变量的初始化是按照代码的先后顺序进行的
public class MyTest2 {
    public static void main(String[] args) {
        TestClass instance = TestClass.getInstance();
        System.out.println(TestClass.a);//1
        System.out.println(TestClass.b);//10
    }
}

class TestClass{
    public static int a;
    public static TestClass testClass = new TestClass();
    private TestClass(){
        a++;
        b++;
        System.out.println("+++"+a);//1
        System.out.println("+++"+b);//1
    }
    public static int b=10;

    public static TestClass getInstance(){
        return testClass;
    }
}
```



## 类的加载

类的加载是指将类的.class文件的二进制数据读入内存，放在运行时数据区的方法区中，然后在内存中创建一个java.lang.Class对象(JVM规范并未说明该对象应放在哪里，HotSpot将其放在方法区), 用来存放类在方法区内的数据结构

### 加载class文件的方式

+ 从本地加载

+ 从网络加载

+ 从.zip, .jar文件加载

+ 从专有数据库中提取

+ **将java源文件动态编译为.class文件**

  > 将jsp文件转换为servlet

## 类的初始化

Java程序对类的使用方式可以分为两种：

+ 主动使用(七种)

  1. 创建类的实例

  2. 访问某个类或接口静态变量，或者对类的静态变量赋值

     > + 如果该静态变量被定义为`static final`,那么在编译阶段，该常量会被存入到调用这个常量的方法所在的**类的常量池**中，调用类并没有直接引用这个定义这个常量的类，因此并不会触发定义常量的类的初始化
     > + 但是如果这个常量的值无法在编译期确定，该常量就不会被放在调用这个常量的方法所在的类的常量池中，这是就是主动使用定义常量的类，那么定义这个常量的类就会被初始化

  3. 调用类的静态方法

     > 2和3对应的助记符为: getStatic, putStatic, invokeStatic
     >
     > 定义该静态变量或者方法的类（接口）才会被初始化，通过子类直接引用父类的静态变量，子类不会被初始化，但是子类依旧会被加载

  4. 反射

  5. 初始化一个类的子类

     > 调用一个接口的静态常量时并没有到初始化阶段，在编译期就把常量进行了替换，因此既不需要初始化父接口也不需要初始化本接口，访问父类的常量也是如此。接口的初始化应该是实现接口或者接口的常量是运行时常量，这时父接口和当前接口都需要初始化

  6. Java虚拟机启动时被标记为启动的类

     > 如包含了main方法的类

  7. jdk1.7开始提供动态语言的支持: 

  java.lang.invoke.MethodHandle实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化，则初始化

+ 被动使用

  除了上述七种，其他对类的使用都是被动使用，不到导致类的初始化

  创建一个类的数组是对该类的被动使用，对于数组实例来说，其类型是JVM在运行期间动态创建出来的，其父类型为`Object`

**所有的Java虚拟机实现必须在每个类或接口被java程序<font style="color:red">首次主动使用</font>时才初始化它们**

