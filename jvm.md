# JVM参数

+ `-XX:+<option>`：开启`option`选项
+ `-XX:-<option>`：关闭`option`选项
+ `-XX:<option>=<value>`：将`option`的值设置为`value`



# JVM助记符

+ `ldc`：表示将int,float,或者string类型的常量从常量池中推送至栈顶
+ `bipush`：表示将单字节(-128~127)的常量推送至栈顶
+ `sipush`：表示将短整型(--32768~32767)的产量推送至栈顶
+ `iconst_0`~`iconst_5`：表示将int型0~5常量推送至栈顶
+ `iconst_m1`: 表示将int型的-1常量推送至栈顶
+ `anewarray`：创建一个引用类型的一维数组，并将其引用值压入栈顶
+ `newarray`：创建一个指定的原始类型的数组，并将其引用压入栈顶
+ `multianewarray`：创建一个（原始类型或引用类型）多维数组，并将其引用值压入栈顶

# JVM的内存模型与内存结构

## 内存结构

Java的内存结构包括堆、栈、方法区等，Java程序启动后会初始化这些内存中的数据。

![image-20200215143420505](C:\Users\14402\AppData\Roaming\Typora\typora-user-images\image-20200215143420505.png)

+ 程序计数器

  > + **说明:**
  >
  >   线程私有的一小块内存空间。
  >
  >   **之所以为私有**：JVM的多线程时通过线程轮流切换并分配处理器时间片的方式实现的，任何确定时刻，一个处理器都只会执行一条线程的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，每条线程之间互不影响。
  >
  >   可以看作当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里，字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的指令，各种基础功能都需要依赖程序计数器
  >
  >   如果正在执行的时一个Java方法，这个程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是一个Native方法，该程序计数器值为空
  >
  > + **异常定义：**
  >
  >   此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

+ 虚拟机栈

  > + **说明：**
  >
  >   该内存区域的生命周期与线程一致，描述了Java方法执行的内存模型：
  >
  >   > 每个方法执行都会创建一个**栈帧**，用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法出入口**等信息。每一个方法从开始到结束的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
  >   >
  >   > 该内存区域最重要的一块为：**局部变量表**
  >   >
  >   > > 这里存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令地址）
  >   > >
  >   > > 处理64位长的long和double类型占用两个**局部变量空间(Slot)**外，其他均为一个
  >   > >
  >   > > 局部变量表的内存空间在编译期完成分配，所以进入一个方法时，这个方法需要在栈帧分配多大的局部变量表时确定的，运行期不会改变
  >
  > + 异常定义
  >
  >   + `StackOverflowError`：线程请求的栈深大于虚拟机允许的深度
  >   + `OutOfMemoryError`: 如果虚拟机栈可以扩展，但是在扩展时无法申请到足够的内存

## 内存模型

JVM的内存模型是和并发息息相关的，目的是保证多线程之间操作共享变量的正确性。关键字：`final`,`volatile`,`synchronized`


# 类加载器

在Java代码中，类型加载、链接与初始化过程都是在程序运行期完成的，这样提供了更大的灵活性和可能性，这点与其他编译型语言在编译期完成有所不同。

+ 类加载：查找并加载类的二进制数据
+ 链接
  + 验证：确保被加载类的正确性
  + 准备：为类的静态变量分配内存，并将其初始化为**默认值**
  + 解析：把类中的符号引用转换为直接引用
+ 初始化：为类的静态变量赋予正确的**初始值**
+ 使用
+ 卸载（可选）

## 类的加载

类的加载是指将类的.class文件的二进制数据读入内存，放在运行时数据区的方法区中，然后在内存中创建一个java.lang.Class对象(JVM规范并未说明该对象应放在哪里，HotSpot将其放在方法区), 用来存放类在方法区内的数据结构

### 加载class文件的方式

+ 从本地加载

+ 从网络加载

+ 从.zip, .jar文件加载

+ 从专有数据库中提取

+ **将java源文件动态编译为.class文件**

  > 将jsp文件转换为servlet

## 类的初始化

Java程序对类的使用方式可以分为两种：

+ 主动使用(七种)

  1. 创建类的实例

  2. 访问某个类或接口静态变量，或者对类的静态变量赋值

     > + 如果该静态变量被定义为`static final`,那么在编译阶段，该常量会被存入到调用这个常量的方法所在的类的常量池中，调用类并没有直接引用这个定义这个常量的类，因此并不会触发定义常量的类的初始化
     > + 但是如果这个常量的值无法在编译期确定，该常量就不会被放在调用这个常量的方法所在的类的常量池中，这是就是主动使用定义常量的类，那么定义这个常量的类就会被初始化

  3. 调用类的静态方法

     > 2和3对应的助记符为: getStatic, putStatic, invokeStatic
     >
     > 定义该静态变量或者方法的类（接口）才会被初始化，通过子类直接引用父类的静态变量，子类不会被初始化，但是子类依旧会被加载

  4. 反射

  5. 初始化一个类的子类

  6. Java虚拟机启动时被标记为启动的类

     > 如包含了main方法的类

  7. jdk1.7开始提供动态语言的支持: 

  java.lang.invoke.MethodHandle实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化，则初始化

+ 被动使用

  除了上述七种，其他对类的使用都是被动使用，不到导致类的初始化

  创建一个类的数组是对该类的被动使用，对于数组实例来说，其类型是JVM在运行期间动态创建出来的，其父类型为`Object`

**所有的Java虚拟机实现必须在每个类或接口被java程序<font style="color:red">首次主动使用</font>时才初始化它们**

