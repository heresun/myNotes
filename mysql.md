

# 事务

一个或一组sql语句组成一个执行单元,要么都执行,要么都不执行.

一个事务中的每一条sql语句都是相互依赖的,一旦有一个执行失败,事务将回滚,回到最初状态

MySQL所支持的存储引擎中,InnoDB支持事务

## 事务的ACID

| 性质                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| 原子性(Atomicity)   | 事务的原子性表明事务是不可分割的工作单位,即要么都发生, 要么都不发生 |
| 一致性(Consistency) | 事务必须使数据库从一个**一致性状态**转换到另一个一致性状态   |
| 隔离性(Isolation)   | 一个事务的执行不被其他事务干扰, 即一个事务内部的操作及使用的数据对其他事务是隔离的, 并发执行的各个事务之间不能相互干扰 |
| 持久性(Durability)  | 一个事务一旦被提交,其对数据库的影响就是**永久性的**, 接下来数据库的其他故障对其不应该有影响 |

## 事务的创建

### 隐式事务

事务没有明显的开启和关闭标记,如update,delete,insert

### 显式事务

事务有明显的开启和关闭标记

==使用显式事务的前提是:关闭自动提交==

查看当前是否为自动提交: `show variables like "autocommit";`

关闭自动提交:`set autocommit=0;`

**创建一个事务:**

```mysql
-- 步骤 1:开启事务
    set autommit=0;    -- 关闭自动提交
    start transaction; -- 可选
-- 步骤 2:编写事务中的sql语句(增删改查),将数据存储到内存,遇到结束事务标记时再决定是回滚还是写入磁盘
	语句1;
	语句2;
	...
-- 步骤 3:结束事务
	commit;            -- 执行成功则提交事务
	rollback;          -- 执行失败则回滚事务
```



## 事务的隔离级别

如果多个事务同时访问数据库中的相同数据, 如果没有采取必要的隔离机制, 会导致如下问题:

 假设有事务T1和事务T2

| 问题       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | T1读取了已经被T2更新但还未被T2提交的记录, 如果T2回滚, 则T1读取的数据是临时且无效的 |
| 不可重复读 | T1读取了一条记录, T2更改了这条记录, T1再次读取这条记录, 结果不同 |
| 幻读       | T1读取了一个表中的数据, 然后T2增加或删除了几条记录,T1再读时发现多出或少了几行记录 |

为了解决以上的问题, 需要设置事务的隔离级别;

### 设置隔离级别

==隔离级别即一个事务与其他事务隔离的程度, 数据库定义了许多隔离级别, 隔离级别越高, 数据一致性越强,但是并发能力越弱.==

Mysql支持以下四种隔离级别:

| 隔离级别                        | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| 读未提交数据( READ UNCOMMITTED) | 允许数据读取已被其他事务更改但还未提交的数据, **脏读\幻读\不可重复读的问题都会出现** |
| 读已提交数据(READ COMMITED)     | 只允许事务读取已被其他事务提交的变更, **可避免脏读**         |
| 可重复读(REPEATABLE READ)       | 确保事务可以多次从一条记录中读取相同的值, 在这个事务执行期间, 禁止其他事务对这条记录进行更新, **可避免脏读和不可重复读** |
| 串行化(SERIALIZABLE)            | 确保一个事务从一个表中读取相同的行, 在这个事务执行期间, 禁止其他事务对该表执行插入 ,更新和删除操作, **避免了所有问题, 但是性能低** |

==Mysql默认的隔离级别是REPEATABLE READ==

查看MySQL的隔离级别:`select @@tx_isolation;`

设置MySQL的隔离级别:`set session transaction isolation level  read uncommit;`

## 回滚点/保存点

```mysql
-- 步骤 1:开启事务
    set autommit=0;    -- 关闭自动提交
    start transaction; -- 可选
-- 步骤 2:编写事务中的sql语句(增删改查),将数据存储到内存,遇到结束事务标记时再决定是回滚还是写入磁盘
	语句1;
	savepoint a; -- 设置一个回滚点, a为该点的名字
	语句2;
	...
-- 步骤 3:结束事务
	rollback to a;          -- 回滚到保存点a, a之后的语句全部回滚,a之前的语句执行成功
```



# 视图

视图是一种虚拟表, 是通过实体表动态生成的, 它的行和列的数据来自于创建该视图的表, 并且是在使用视图时动态生成的, 视图只保存了sql逻辑, 不保存查询结果,其应用场景为:

+ 多个地方用到相同的查询结果
+ 该查询结果使用到的查询语句较复杂

优点:

+ 实现了sql语句的重用
+ 简化了sql语句, 不必知道其实现细节
+ 保护数据, 提高安全性, 对原始表的数据进行了隐藏

## 视图的创建

```mysql
-- 创建视图
-- create view 视图名
-- as 查询语句
create view my_view
as
select stuname, majorname
from stuinfo s
inner join major m on s.major_id = m.id;
-- 使用视图
select * from my_view where stuname like "孙%";

-- 以上等价于如下代码
select * from stuinfo s
inner join major m on s.major_id = m.id
where s.stuname like "孙%";
```

==使用视图时就把它当作一个表==

## 视图的修改

### 方式一:

```mysql
create or replace my_view -- 没有就创建该视图,有就修改
as 新的mysql语句
```

### 方式二:

```mysql
alter view my_view
as 新的mysql语句
```



## 删除视图

```mysql
drop view 视图1, 视图2 ,...;
```

## 查看视图

```mysql
-- 方法一
	desc my_veiw;
-- 方法二
	show create view my_view;
```

## 更新视图

视图最好只读,不要修改,但是可以修改

只有简单列,即视图中的列和原始表中的列一样, 可以向更新一个表一样更新视图,并且对原始表产生同样的影响

![image-20200303222224024](C:\Users\14402\AppData\Roaming\Typora\typora-user-images\image-20200303222224024.png)

## 视图和表的对比

|      | 创建语法不一样 | 是否占用磁盘空间 | 是否可以更新 |
| ---- | -------------- | ---------------- | ------------ |
| 视图 | create view    | 否               | 否           |
| 表   | create table   | 是               | 是           |

